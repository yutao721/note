<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前言 | jiaHang的博客</title>
    <meta name="generator" content="VuePress 1.5.0">
    
    <meta name="description" content="专注前端技术栈分享，做一个爱折腾的前端">
    <link rel="preload" href="/note/assets/css/0.styles.725ed339.css" as="style"><link rel="preload" href="/note/assets/js/app.02190172.js" as="script"><link rel="preload" href="/note/assets/js/2.2dccd611.js" as="script"><link rel="preload" href="/note/assets/js/11.7ceb6923.js" as="script"><link rel="prefetch" href="/note/assets/js/10.a05513c9.js"><link rel="prefetch" href="/note/assets/js/12.fb88bae4.js"><link rel="prefetch" href="/note/assets/js/13.4b17ba74.js"><link rel="prefetch" href="/note/assets/js/14.ce1cd100.js"><link rel="prefetch" href="/note/assets/js/15.6a480c60.js"><link rel="prefetch" href="/note/assets/js/16.6d6b8a6a.js"><link rel="prefetch" href="/note/assets/js/17.c36721ad.js"><link rel="prefetch" href="/note/assets/js/18.77bcea9f.js"><link rel="prefetch" href="/note/assets/js/19.f262839a.js"><link rel="prefetch" href="/note/assets/js/20.5b1b9830.js"><link rel="prefetch" href="/note/assets/js/21.76b74656.js"><link rel="prefetch" href="/note/assets/js/22.e663cec2.js"><link rel="prefetch" href="/note/assets/js/23.c1f1c7e7.js"><link rel="prefetch" href="/note/assets/js/24.5ddffc93.js"><link rel="prefetch" href="/note/assets/js/25.95b0061c.js"><link rel="prefetch" href="/note/assets/js/26.c4c127de.js"><link rel="prefetch" href="/note/assets/js/27.234a7f7e.js"><link rel="prefetch" href="/note/assets/js/28.3bb3b4b8.js"><link rel="prefetch" href="/note/assets/js/29.1339c108.js"><link rel="prefetch" href="/note/assets/js/3.6e8c2ef0.js"><link rel="prefetch" href="/note/assets/js/30.3235f9a2.js"><link rel="prefetch" href="/note/assets/js/31.2a4efe07.js"><link rel="prefetch" href="/note/assets/js/32.d3d3c893.js"><link rel="prefetch" href="/note/assets/js/33.eaca5eef.js"><link rel="prefetch" href="/note/assets/js/34.684f8bf3.js"><link rel="prefetch" href="/note/assets/js/35.c486c7ec.js"><link rel="prefetch" href="/note/assets/js/36.2f90f872.js"><link rel="prefetch" href="/note/assets/js/37.92460be1.js"><link rel="prefetch" href="/note/assets/js/38.8532070d.js"><link rel="prefetch" href="/note/assets/js/39.9cc3b3d9.js"><link rel="prefetch" href="/note/assets/js/4.2b7fc900.js"><link rel="prefetch" href="/note/assets/js/40.3ec1b99e.js"><link rel="prefetch" href="/note/assets/js/41.d22f0de1.js"><link rel="prefetch" href="/note/assets/js/42.4796d96b.js"><link rel="prefetch" href="/note/assets/js/43.4c97d146.js"><link rel="prefetch" href="/note/assets/js/44.6e02569c.js"><link rel="prefetch" href="/note/assets/js/5.bb5b8508.js"><link rel="prefetch" href="/note/assets/js/6.ec170bea.js"><link rel="prefetch" href="/note/assets/js/7.12a33526.js"><link rel="prefetch" href="/note/assets/js/8.70ad78c1.js"><link rel="prefetch" href="/note/assets/js/9.b2f872fe.js">
    <link rel="stylesheet" href="/note/assets/css/0.styles.725ed339.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/note/" class="home-link router-link-active"><!----> <span class="site-name">jiaHang的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/note/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/note/web/" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/note/node/" class="nav-link router-link-active">
  node
</a></div><div class="nav-item"><a href="/note/interview/" class="nav-link">
  面试问题
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/note/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/note/web/" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/note/node/" class="nav-link router-link-active">
  node
</a></div><div class="nav-item"><a href="/note/interview/" class="nav-link">
  面试问题
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/note/node/" aria-current="page" class="sidebar-link">node目录</a></li><li><a href="/note/node/01_what.html" class="sidebar-link">Node介绍</a></li><li><a href="/note/node/02_module.html" class="sidebar-link">Node模块机制</a></li><li><a href="/note/node/path.html" aria-current="page" class="active sidebar-link">path模块</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/node/path.html#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header"><a href="/note/node/path.html#node-中的路径分类" class="sidebar-link">node 中的路径分类</a></li><li class="sidebar-sub-header"><a href="/note/node/path.html#path-dirname" class="sidebar-link">path.dirname</a></li><li class="sidebar-sub-header"><a href="/note/node/path.html#path-extname" class="sidebar-link">path.extname</a></li><li class="sidebar-sub-header"><a href="/note/node/path.html#path-basename" class="sidebar-link">path.basename</a></li><li class="sidebar-sub-header"><a href="/note/node/path.html#path-normalize" class="sidebar-link">path.normalize</a></li><li class="sidebar-sub-header"><a href="/note/node/path.html#path-isabsolute" class="sidebar-link">path.isAbsolute</a></li><li class="sidebar-sub-header"><a href="/note/node/path.html#path-parse" class="sidebar-link">path.parse</a></li><li class="sidebar-sub-header"><a href="/note/node/path.html#path-format" class="sidebar-link">path.format</a></li><li class="sidebar-sub-header"><a href="/note/node/path.html#path-join" class="sidebar-link">path.join</a></li><li class="sidebar-sub-header"><a href="/note/node/path.html#path-resolve" class="sidebar-link">path.resolve</a></li><li class="sidebar-sub-header"><a href="/note/node/path.html#path-relative" class="sidebar-link">path.relative</a></li><li class="sidebar-sub-header"><a href="/note/node/path.html#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/note/node/fs.html" class="sidebar-link">fs模块</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p><strong>path</strong>模块是Node的核心模块之一，特别是在前端项目构建，打包等操作中，是使用比较频繁的API。</p> <h2 id="node-中的路径分类"><a href="#node-中的路径分类" class="header-anchor">#</a> node 中的路径分类</h2> <p>node 中的路径大致分 5 类，<code>__dirname</code>,<code>__filename</code>,<code>process.cwd()</code>,<code>./</code>,<code>../</code>,其中<code>__dirname</code>,<code>__filename</code>,<code>process.cwd()</code>绝对路径</p> <ul><li><code>__dirname</code>： 获得当前执行文件所在目录的完整目录名</li> <li><code>__filename</code>： 获得当前执行文件的带有完整绝对路径的文件名</li> <li><code>process.cwd()</code>：获得当前执行node命令时候的文件夹目录名</li> <li><code>./</code>： 不使用require时候，<code>./</code>与<code>process.cwd()</code>一样，使用<code>require</code>时候，与<code>__dirname</code>一样</li></ul> <blockquote><p>那么关于 <code>./</code>的结论是：</p> <p>在 <code>require()</code>中使用是跟<code>__dirname</code> 的效果相同，不会因为启动脚本的目录不一样而改变，在其他情况下跟 <code>process.cwd()</code> 效果相同，是相对于启动脚本所在目录的路径。</p> <p>只有在 require() 时才使用相对路径(./, ../) 的写法，其他地方一律使用绝对路径，如下：</p></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 当前目录下</span>
path<span class="token punctuation">.</span><span class="token function">dirname</span><span class="token punctuation">(</span>__filename<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'/path.js'</span>
<span class="token comment">// 相邻目录下</span>
path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'../regx/regx.js'</span><span class="token punctuation">)</span>
</code></pre></div><p>前面讲解了路径的相关比较，接下来单独聊聊 path 这个模块，这个模块在很多地方比较常用，所以，对于我们来说，掌握他，对我们以后的发展更有利，不用每次看 webpack 的配置文件还要去查询一下这个 api 是干什么用的，很影响我们的效率。</p> <h2 id="path-dirname"><a href="#path-dirname" class="header-anchor">#</a> path.dirname</h2> <p><code>path.dirname(path)</code> 方法返回 <code>path</code> 的目录名，类似于 Unix <code>dirname</code> 命令,尾随的目录分隔符被忽略。</p> <div class="language-js extra-class"><pre class="language-js"><code>path<span class="token punctuation">.</span><span class="token function">dirname</span><span class="token punctuation">(</span><span class="token string">'/foo/bar/baz/asdf/quux'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 返回: '/foo/bar/baz/asdf'</span>
</code></pre></div><h2 id="path-extname"><a href="#path-extname" class="header-anchor">#</a> path.extname</h2> <p><code>path.extname(path)</code> 方法返回 <code>path</code> 的扩展名，即 <code>path</code> 的最后一部分中从最后一次出现的 <code>.</code>（句点）字符到字符串的结尾。 如果 <code>path</code> 的最后一部分中没有 <code>.</code>，或者除了 <code>path</code> 的基本名称的第一个字符之外没有 <code>.</code> 个字符，则返回空字符串。</p> <div class="language-js extra-class"><pre class="language-js"><code>path<span class="token punctuation">.</span><span class="token function">extname</span><span class="token punctuation">(</span><span class="token string">'index.html'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 返回: '.html'</span>

path<span class="token punctuation">.</span><span class="token function">extname</span><span class="token punctuation">(</span><span class="token string">'index.coffee.md'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 返回: '.md'</span>

path<span class="token punctuation">.</span><span class="token function">extname</span><span class="token punctuation">(</span><span class="token string">'index.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 返回: '.'</span>

path<span class="token punctuation">.</span><span class="token function">extname</span><span class="token punctuation">(</span><span class="token string">'index'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 返回: ''</span>

path<span class="token punctuation">.</span><span class="token function">extname</span><span class="token punctuation">(</span><span class="token string">'.index'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 返回: ''</span>

path<span class="token punctuation">.</span><span class="token function">extname</span><span class="token punctuation">(</span><span class="token string">'.index.md'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 返回: '.md'</span>
</code></pre></div><h2 id="path-basename"><a href="#path-basename" class="header-anchor">#</a> path.basename</h2> <p>path.basename(path[, ext])方法返回 <code>path</code> 的最后一部分,接收两个参数，第一个是<code>path</code>，第二个是<code>ext</code>(可选参数)，当输入第二个参数的时候，打印结果不出现后缀名。</p> <div class="language-js extra-class"><pre class="language-js"><code>path<span class="token punctuation">.</span><span class="token function">basename</span><span class="token punctuation">(</span><span class="token string">'/foo/bar/baz/asdf/quux.html'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 返回: 'quux.html'</span>

path<span class="token punctuation">.</span><span class="token function">basename</span><span class="token punctuation">(</span><span class="token string">'/foo/bar/baz/asdf/quux.html'</span><span class="token punctuation">,</span> <span class="token string">'.html'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 返回: 'quux'</span>
</code></pre></div><p>尽管 Windows 通常以不区分大小写的方式处理文件名（包括文件扩展名），但此函数不会。 例如，<code>C:\\foo.html</code> 和 <code>C:\\foo.HTML</code> 指的是同一个文件，但 <code>basename</code> 将扩展名视为区分大小写的字符串：</p> <div class="language-js extra-class"><pre class="language-js"><code>path<span class="token punctuation">.</span>win32<span class="token punctuation">.</span><span class="token function">basename</span><span class="token punctuation">(</span><span class="token string">'C:\\foo.html'</span><span class="token punctuation">,</span> <span class="token string">'.html'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 返回: 'foo'</span>

path<span class="token punctuation">.</span>win32<span class="token punctuation">.</span><span class="token function">basename</span><span class="token punctuation">(</span><span class="token string">'C:\\foo.HTML'</span><span class="token punctuation">,</span> <span class="token string">'.html'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 返回: 'foo.HTML'</span>
</code></pre></div><h2 id="path-normalize"><a href="#path-normalize" class="header-anchor">#</a> path.normalize</h2> <p>规范化路径，把不规范的路径规范化</p> <div class="language-js extra-class"><pre class="language-js"><code>path<span class="token punctuation">.</span><span class="token function">normalize</span><span class="token punctuation">(</span><span class="token string">'/path///example/index.js'</span><span class="token punctuation">)</span> <span class="token comment">//  /path/example/index.js</span>
</code></pre></div><h2 id="path-isabsolute"><a href="#path-isabsolute" class="header-anchor">#</a> path.isAbsolute</h2> <p><code>path.isAbsolute()</code> 方法确定 <code>path</code> 是否为绝对路径。</p> <div class="language-js extra-class"><pre class="language-js"><code>path<span class="token punctuation">.</span><span class="token function">isAbsolute</span><span class="token punctuation">(</span><span class="token string">'/foo/bar'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
path<span class="token punctuation">.</span><span class="token function">isAbsolute</span><span class="token punctuation">(</span><span class="token string">'/baz/..'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true</span>
path<span class="token punctuation">.</span><span class="token function">isAbsolute</span><span class="token punctuation">(</span><span class="token string">'qux/'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// false</span>
path<span class="token punctuation">.</span><span class="token function">isAbsolute</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// false</span>
</code></pre></div><h2 id="path-parse"><a href="#path-parse" class="header-anchor">#</a> path.parse</h2> <p>path.parse(path)返回的是一个对象.</p> <div class="language-js extra-class"><pre class="language-js"><code>path<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">'/path/example/index.js'</span><span class="token punctuation">)</span>

<span class="token comment">/*
 { root: '/',
  dir: '/path/example',
  base: 'index.js',
  ext: '.js',
  name: 'index' }
*/</span>

</code></pre></div><ul><li>root：代表根目录</li> <li>dir：代表文件所在的文件夹</li> <li>base：代表整一个文件</li> <li>name：代表文件名</li> <li>ext: 代表文件的后缀名</li></ul> <h2 id="path-format"><a href="#path-format" class="header-anchor">#</a> path.format</h2> <p><code>path.format()</code> 方法从对象返回路径字符串。 这与 <code>path.parse()</code> 相反</p> <div class="language-js extra-class"><pre class="language-js"><code>path<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  root<span class="token operator">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span>
  dir<span class="token operator">:</span> <span class="token string">'/path/example'</span><span class="token punctuation">,</span>
  base<span class="token operator">:</span> <span class="token string">'index.js'</span><span class="token punctuation">,</span>
  ext<span class="token operator">:</span> <span class="token string">'.js'</span><span class="token punctuation">,</span>
  name<span class="token operator">:</span> <span class="token string">'index'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// /path/example/index.js</span>

</code></pre></div><h2 id="path-join"><a href="#path-join" class="header-anchor">#</a> path.join</h2> <p>path.join([...paths])，传入的参数是字符串的路径片段，可以是一个，也可以是多个。返回的是一个拼接好的路径，但是根据平台的不同，他会对路径进行不同的规范化，举个例子，<code>Unix</code>系统是<code>/</code>，<code>Windows</code>系统是<code>\</code>，那么你在两个系统下看到的返回结果就不一样。如果返回的路径字符串长度为零，那么他会返回一个<code>.</code>，代表当前的文件夹。如果传入的参数中有不是字符串的，那就直接会报错</p> <div class="language-js extra-class"><pre class="language-js"><code>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'/path'</span><span class="token punctuation">,</span> <span class="token string">'example'</span><span class="token punctuation">,</span> <span class="token string">'./index.js'</span><span class="token punctuation">)</span> <span class="token comment">// /path/example/index.js</span>
</code></pre></div><h2 id="path-resolve"><a href="#path-resolve" class="header-anchor">#</a> path.resolve</h2> <p>path.resolve([...paths])</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'/foo/bar'</span><span class="token punctuation">,</span> <span class="token string">'/bar/faa'</span><span class="token punctuation">,</span> <span class="token string">'..'</span><span class="token punctuation">,</span> <span class="token string">'a/../c'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// /bar/c</span>
</code></pre></div><p>path.resolve 就相当于是 shell 下面的<code>cd</code>操作，从左到右运行一遍<code>cd path</code>命令，最终获取的绝对路径/文件名，这个接口所返回的结果了。但是<code>resolve</code>操作和<code>cd</code>操作还是有区别的，<code>resolve</code>的路径可以没有，而且最后进入的可以是文件。具体<code>cd</code>步骤如下</p> <div class="language-js extra-class"><pre class="language-js"><code>cd <span class="token operator">/</span>foo<span class="token operator">/</span>bar<span class="token operator">/</span>    <span class="token comment">//这是第一步, 现在的位置是/foo/bar/</span>
cd <span class="token operator">/</span>bar<span class="token operator">/</span>faa     <span class="token comment">//这是第二步，这里和第一步有区别，他是从/进入的，也就时候根目录，现在的位置是/bar/faa</span>
cd <span class="token punctuation">.</span><span class="token punctuation">.</span>       <span class="token comment">//第三步，从faa退出来，现在的位置是 /bar</span>
cd a<span class="token operator">/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span>c   <span class="token comment">//第四步，进入a，然后在推出，在进入c，最后位置是/bar/c</span>

</code></pre></div><p><strong>如果没有传入 <code>path</code> 片段，则 <code>path.resolve()</code> 将返回当前工作目录的绝对路径</strong></p> <h2 id="path-relative"><a href="#path-relative" class="header-anchor">#</a> path.relative</h2> <p>path.relative(from, to) 获取 from 到 to 的相对路径。,如果 from、to 指向同个路径，那么，返回空字符串,如果 from、to 中任一者为空，那么，返回当前工作路径.</p> <div class="language-js extra-class"><pre class="language-js"><code>path<span class="token punctuation">.</span><span class="token function">relative</span><span class="token punctuation">(</span><span class="token string">'/path/example/index.js'</span><span class="token punctuation">,</span> <span class="token string">'/path'</span><span class="token punctuation">)</span> <span class="token comment">// ../..</span>
</code></pre></div><h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>关于路径的知识就说到这里，基础很重要的，既能节约开发时间，又能减少报错。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/note/node/02_module.html" class="prev">
        Node模块机制
      </a></span> <span class="next"><a href="/note/node/fs.html">
        fs模块
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/note/assets/js/app.02190172.js" defer></script><script src="/note/assets/js/2.2dccd611.js" defer></script><script src="/note/assets/js/11.7ceb6923.js" defer></script>
  </body>
</html>
