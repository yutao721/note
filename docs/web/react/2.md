## react Dom-diff之单节点diff

> 上篇文章已经了解到了react 的初次渲染，这篇文章来看下react中的单节点Dom-diff

```js
function commitRoot() {
  //指向新构建的fiber树
  const finishedWork = workInProgressRoot.current.alternate;
  workInProgressRoot.finishedWork = finishedWork;
  commitMutationEffects(workInProgressRoot);
}
```

commitRoot就是提交fiber,修改dom的阶段，dom-diff就在这个阶段。**commitMutationEffects**中有个分支，就是当fiber的flags是Placement（添加 或者说创建 挂载），会有个commitPlacement的操作，看下之前的代码。

```js
function commitMutationEffects(root) {
  const finishedWork = root.finishedWork;
  let nextEffect = finishedWork.firstEffect;
  let effectsList = '';
  while (nextEffect) {
    effectsList += `(${getFlags(nextEffect.flags)}#${nextEffect.type}#${nextEffect.key})`;
    const flags = nextEffect.flags;
    if (flags === Placement) {
      commitPlacement(nextEffect);
    }
    nextEffect = nextEffect.nextEffect;
  }
  effectsList += 'null';
  console.log(effectsList);
  root.current = finishedWork;
}
```

### ReactFiberCommitWork.js

commitPlacement只是其中的一个节点的操作，我们将commitPlacement等相关方法提取到ReactFiberCommitWork.js中去。并且稍作改造。

```diff
export function commitPlacement(nextEffect) {
  let stateNode = nextEffect.stateNode;
  let parentStateNode = getParentStateNode(nextEffect);
-  parentStateNode.appendChild(stateNode);
+  appendChild(parentStateNode, stateNode);
}
```

也是用来抹平平台差异性的操作。appendChild方法也来自ReactDOMComponent.js(真实dom操作)

```js
export function appendChild(parentInstance, child) {
    parentInstance.appendChild(child);
}
```

结果也是一样的，页面上也是渲染出来了title。接下来看下单节点dom-diff是如何实现的。

在beginWork(current, workInProgress)的时候，传入了当前的fiber树和正在构建的fiber树，而且在reconcileChildren的时候，并且是更新操作的时候就会进行比较。

```js
export function reconcileChildren(current, workInProgress, nextChildren) {
  //如果current有值，说明这是一类似于更新的作品
  if (current) {
    //进行比较 新老内容，得到差异进行更新
    workInProgress.child = reconcileChildFibers(
      workInProgress,//新fiber
      current.child,//老fiber的第一个子fiber节点
      nextChildren //新的虚拟DOM
    );
  } else {
    ///初次渲染，不需要比较 ，全是新的
    workInProgress.child = mountChildFibers(
      workInProgress,//新fiber
      null,//老fiber的第一个子fiber节点
      nextChildren //新的虚拟DOM
    );
  }
}
```

```js
/**
   *
   * @param {*} returnFiber 新的父fiber
   * @param {*} currentFirstChild current就是老的意思，老的第一个子fiber
   * @param {*} newChild 新的虚拟DOM
   */
  function reconcileChildFibers(returnFiber, currentFirstChild, newChild) {
    //判断newChild是不是一个对象,如果是的话说明新的虚拟DOM只有一个React元素节点
    const isObject = typeof newChild === 'object' && ( newChild );
    //说明新的虚拟DOM是单节点
    if (isObject) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return placeSingleChild(reconcileSingleElement(
            returnFiber, currentFirstChild, newChild
          ));
      }
    }
  }
```

单节点的diff会走到reconcileSingleElement中去，目前reconcileSingleElement还只是直接创建一个fiber节点，并没有对比的过程。

```js
function reconcileSingleElement(returnFiber, currentFirstChild, element) {
  const created = createFiberFromElement(element);//div#title
  created.return = returnFiber;
  return created;
}
```

先来看下更新情况下，当前current和正在构建的workInProgress的关系图：

![](https://gitee.com/yutao618/images/raw/master/images/cong_render_dao_zhi_xing_gong_zuo_xun_huan_de_fiber_jia_gou_4_1636817909854.jpg)

> current永远是老的fiber树，就是当前页面视图对应的fiber树，workInProgress是当前正在构建的fiber树，他们相互指向，相互引用，就是之前说的双缓冲。

### 

![](https://gitee.com/yutao618/images/raw/master/images/dan_jie_dian_diff_1636818669377.jpg)

上图是单节点的diff流程图，按这个，我们就分为以下几种情况：

### key相同,类型相同,复用老节点，只更新属性

具体代码实现：

```js
function reconcileSingleElement(returnFiber, currentFirstChild, element) {
  //获取新的虚拟DOM的key
  let key = element.key;
  //获取第一个老的fiber节点
  let child = currentFirstChild;
  while (child) {
    //老fiber的ekey和新的虚拟DOM的key相同说明
    if (child.key === key) {
      
    } else {
      //如果不相同说明当前这个老fiber不是对应于新的虚拟DOM节点 把此老fiber标记为删除
      deleteChild(returnFiber, child);
    }
  }
  const created = createFiberFromElement(element);//div#title
  created.return = returnFiber;
  return created;
}
```

![](https://gitee.com/yutao618/images/raw/master/images/20211213171923.png)

```js
/**
 * 因为这个老的子fiber在新的虚拟DOM树不存在了，则标记为删除
 * @param {*} returnFiber
 * @param {*} childToDelete
 */
function deleteChild(returnFiber, childToDelete) {
  //如果不需要跟踪副作用，直接返回
  if (!shouldTrackSideEffects) {
    return;
  }
  //把自己这个副作用添加到父effectList中
  //删除类型的副作用一般放在父fiber副作用链表的前面，在进行DOM操作时候先执行删除操作
  const lastEffect = returnFiber.lastEffect;
  if (lastEffect) {
    lastEffect.nextEffect = childToDelete;
    returnFiber.lastEffect = childToDelete;
  } else {
    //父fiber节点effectList是空
    returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
  }
  //清空下一个副作用指向
  childToDelete.nextEffect = null;
  //标记为删除
  childToDelete.flags = Deletion;
}
```

接下来就是处理下一个fiber,也就是它的sibling。

![](https://gitee.com/yutao618/images/raw/master/images/20211213174410.png)

```diff
function reconcileSingleElement(returnFiber, currentFirstChild, element) {
  //获取新的虚拟DOM的key
  let key = element.key;
  //获取第一个老的fiber节点
  let child = currentFirstChild;
  while (child) {
    //老fiber的ekey和新的虚拟DOM的key相同说明
    if (child.key === key) {
    
    } else {
      //如果相同说明当前这个老fiber不是对应于新的虚拟DOM节点 把此老fiber标记为删除，并且继续弟弟
      deleteChild(returnFiber, child);
    }
+   // 继续匹配弟弟们
+   child = child.sibling;
  }
  const created = createFiberFromElement(element);//div#title
  created.return = returnFiber;
  return created;
}
```

那此时key相同，按照流程图，就看下type是否相同，如果不相同，则删除包括当前的老fiber在内所所有后续的老fibe

```diff
while (child) {
  //老fiber的ekey和新的虚拟DOM的key相同说明
  if (child.key === key) {
    //判断老的fiber的type和新的虚拟DOMtype是否相同
    if (child.type == element.type) {

    } else {
+      //已经配上key了，但是type不同，则删除包括当前的老fiber在内所所有后续的老fibe
+      deleteRemainingChildren(returnFiber, child);
+      break;
    }
  } else {
    //如果不相同说明当前这个老fiber不是对应于新的虚拟DOM节点 把此老fiber标记为删除
    deleteChild(returnFiber, child);
    child = child.sibling;
  }
}
```

复用child老fiber节点，删除剩下的其它fiber

```js
function deleteRemainingChildren(returnFiber, childToDelete) {
  while (childToDelete) {
    deleteChild(returnFiber, childToDelete);
    childToDelete = childToDelete.sibling;
  }
}
```

type如果是相同的，那就可以直接使用原来的fiber,并且更新属性

```diff
while (child) {
  //老fiber的ekey和新的虚拟DOM的key相同说明
  if (child.key === key) {
    //判断老的fiber的type和新的虚拟DOMtype是否相同
    if (child.type == element.type) {
+      //准备复用child老fiber节点，删除剩下的其它fiber
+      deleteRemainingChildren(returnFiber, child.sibling);
+      //在复用老fiber的时候，会传递新的虚拟DOM的属性对象到新fiber的pendingProps上
+      const existing = useFiber(child, element.props);
+      existing.return = returnFiber;
+      return existing;
    } else {
      //已经配上key了，但是type不同，则删除包括当前的老fiber在内所所有后续的老fibe
      deleteRemainingChildren(returnFiber, child);
      break;
    }
  } else {
    //如果相同说明当前这个老fiber不是对应于新的虚拟DOM节点 把此老fiber标记为删除，并且继续弟弟
    deleteChild(returnFiber, child);
  }
  //继续匹配弟弟们
  child = child.sibling;
}
```

复用老fiber,并

```
function useFiber(oldFiber, pendingProps) {
  let clone = createWorkInProgress(oldFiber, pendingProps);
  clone.sibling = null;//清空弟弟
  return clone;
}
```